{"version":3,"file":"react-hooks.cjs.production.min.js","sources":["../src/usePrevious.ts","../src/useMergeRefs.ts","../src/useOnClickOutside.ts","../src/useAsyncEffect.ts","../src/useClipboard.ts","../src/useConstant.ts","../src/useDebounce.ts","../src/useDisclosure.ts","../src/useForceUpdate.ts","../src/useHasMounted.ts","../src/useLockBodyScroll.ts","../src/useMedia.ts","../src/usePagination.ts","../src/useWhyDidYouUpdate.ts"],"sourcesContent":["import { useEffect, useRef } from 'react'\n\n/**\n * React hook that tracks previous value\n *\n * @param value the value to track\n */\nexport default function usePrevious<T>(value: T) {\n  const valueRef = useRef<T>()\n\n  useEffect(() => {\n    valueRef.current = value\n  }, [value])\n\n  return valueRef.current as T\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\nimport * as React from 'react'\n\ntype ReactRef<T> = React.Ref<T> | React.MutableRefObject<T>\n\nexport function assignRef<T = any>(ref: ReactRef<T> | undefined, value: T) {\n  if (ref == null) return\n\n  if (typeof ref === 'function') {\n    ref(value)\n    return\n  }\n\n  try {\n    // @ts-ignore\n    ref.current = value\n  } catch (error) {\n    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`)\n  }\n}\n\n/**\n * React hook that merges react refs into a single memoized function\n *\n * @example\n * import React from \"react\";\n * import { useMergeRefs } from `@chakra-ui/hooks`;\n *\n * const Component = React.forwardRef((props, ref) => {\n *   const internalRef = React.useRef();\n *   return <div {...props} ref={useMergeRefs(internalRef, ref)} />;\n * });\n */\nexport default function useMergeRefs<T>(...refs: (ReactRef<T> | undefined)[]) {\n  return React.useMemo(() => {\n    if (refs.every((ref) => ref == null)) {\n      return null\n    }\n    return (node: T) => {\n      refs.forEach((ref) => {\n        if (ref) assignRef(ref, node)\n      })\n    }\n  }, refs)\n}\n","import React, { useEffect } from 'react'\n\nconst MOUSEDOWN = 'mousedown'\nconst TOUCHSTART = 'touchstart'\n\ntype HandledEvents = [typeof MOUSEDOWN, typeof TOUCHSTART]\ntype HandledEventsType = HandledEvents[number]\ntype PossibleEvent = {\n  [Type in HandledEventsType]: HTMLElementEventMap[Type]\n}[HandledEventsType]\ntype Handler = (event: PossibleEvent) => void\n\nconst events: HandledEvents = [MOUSEDOWN, TOUCHSTART]\n\nexport default function useOnClickOutside(\n  ref: React.RefObject<HTMLElement>,\n  handler: Handler,\n) {\n  useEffect(\n    () => {\n      if (!handler) {\n        return\n      }\n\n      const listener = (event: PossibleEvent) => {\n        // Do nothing if clicking ref's element or descendent elements\n        if (!ref.current || ref.current.contains(event.target as Node)) {\n          return\n        }\n        handler(event)\n      }\n\n      events.forEach((event) => {\n        document.addEventListener(event, listener)\n      })\n\n      return () => {\n        events.forEach((event) => {\n          document.removeEventListener(event, listener)\n        })\n      }\n    },\n    // Add ref and handler to effect dependencies\n    // It's worth noting that because passed in handler is a new ...\n    // ... function on every render that will cause this effect ...\n    // ... callback/cleanup to run every render. It's not a big deal ...\n    // ... but to optimize you can wrap handler in useCallback before ...\n    // ... passing it into this hook.\n    [ref, handler],\n  )\n}\n","import { useEffect } from 'react'\n\nexport default function useAsyncEffect<Data = any>(\n  callback: (isMounted: () => boolean) => Data | Promise<Data>,\n  onDestroyOrDependencies: null | ((result?: Data) => void) | any[] = [],\n  dependencies: any[] = [],\n) {\n  let deps: any[]\n  let destroy: (result?: Data) => void\n\n  if (typeof onDestroyOrDependencies === 'function') {\n    destroy = onDestroyOrDependencies\n    deps = dependencies\n  } else {\n    deps = onDestroyOrDependencies || []\n  }\n\n  useEffect(() => {\n    let result: Data\n    let mounted = true\n\n    const maybePromise = callback(() => {\n      return mounted\n    })\n\n    Promise.resolve(maybePromise).then((value) => {\n      result = value\n    })\n\n    return () => {\n      mounted = false\n\n      if (typeof destroy === 'function') {\n        destroy(result)\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps)\n}\n","import { useState, useCallback, useEffect } from 'react'\nimport copy from 'copy-to-clipboard'\n\nexport interface UseClipboardOptions {\n  /**\n   * timeout delay (in ms) to switch back to initial state once copied.\n   */\n  timeout?: number\n  /**\n   * Set the desired MIME type\n   */\n  format?: string\n}\n\n/**\n * React hook to copy content to clipboard\n *\n * @param text the text or value to copy\n * @param {Number} [optionsOrTimeout=1500] optionsOrTimeout - delay (in ms) to switch back to initial state once copied.\n * @param {Object} optionsOrTimeout\n * @param {string} optionsOrTimeout.format - set the desired MIME type\n * @param {number} optionsOrTimeout.timeout - delay (in ms) to switch back to initial state once copied.\n */\nexport default function useClipboard(\n  text: string,\n  optionsOrTimeout: number | UseClipboardOptions = {},\n) {\n  const [hasCopied, setHasCopied] = useState(false)\n\n  const { timeout = 1500, ...copyOptions } =\n    typeof optionsOrTimeout === 'number'\n      ? { timeout: optionsOrTimeout }\n      : optionsOrTimeout\n\n  const onCopy = useCallback(() => {\n    const didCopy = copy(text, copyOptions)\n    setHasCopied(didCopy)\n  }, [text, copyOptions])\n\n  useEffect(() => {\n    let timeoutId: number | null = null\n\n    if (hasCopied) {\n      timeoutId = window.setTimeout(() => {\n        setHasCopied(false)\n      }, timeout)\n    }\n\n    return () => {\n      if (timeoutId) {\n        window.clearTimeout(timeoutId)\n      }\n    }\n  }, [timeout, hasCopied])\n\n  return { value: text, onCopy, hasCopied }\n}\n","import { useRef } from 'react'\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nexport default function useConst<T extends any | (() => any)>(init: T) {\n  const ref = useRef<T | null>(null)\n\n  if (ref.current === null) {\n    ref.current = typeof init === 'function' ? init() : init\n  }\n\n  return ref.current as T\n}\n","import { useEffect, useState } from 'react'\n\nexport default function useDebounce<T>(value: T, delay: number): T {\n  // State and setters for debounced value\n  const [debouncedValue, setDebouncedValue] = useState<T>(value)\n  useEffect(\n    () => {\n      // Update debounced value after delay\n      const handler = setTimeout(() => {\n        setDebouncedValue(value)\n      }, delay)\n      // Cancel the timeout if value changes (also on delay change or unmount)\n      // This is how we prevent debounced value from updating if value is changed ...\n      // .. within the delay period. Timeout gets cleared and restarted.\n      return () => {\n        clearTimeout(handler)\n      }\n    },\n    [value, delay], // Only re-call effect if value or delay changes\n  )\n  return debouncedValue\n}\n","import { useState, useCallback } from 'react'\nimport usePrevious from './usePrevious'\n\nexport interface UseDisclosureProps {\n  defaultIsOpen?: boolean\n  onClose?(): void\n  onOpen?(): void\n}\n\nexport default function useDisclosure(props: UseDisclosureProps = {}) {\n  const { onClose: onCloseProp, onOpen: onOpenProp } = props\n\n  const [isOpen, setIsOpen] = useState(props.defaultIsOpen || false)\n\n  const prevIsOpen = usePrevious(isOpen)\n\n  const onClose = useCallback(() => {\n    setIsOpen(false)\n    if (onCloseProp) {\n      onCloseProp()\n    }\n  }, [onCloseProp])\n\n  const onOpen = useCallback(() => {\n    setIsOpen(true)\n    if (onOpenProp) {\n      onOpenProp()\n    }\n  }, [onOpenProp])\n\n  const onToggle = useCallback(() => {\n    const action = isOpen ? onClose : onOpen\n    action()\n  }, [isOpen, onOpen, onClose])\n\n  return {\n    isOpen: !!isOpen,\n    prevIsOpen: !!prevIsOpen,\n    onOpen,\n    onClose,\n    onToggle,\n  }\n}\n\nexport type UseDisclosureReturn = ReturnType<typeof useDisclosure>\n","import { useState, useCallback } from 'react'\n\n/**\n * React hook for force a component to re-render\n */\nexport default function useForceUpdate() {\n  const [count, setCount] = useState(0)\n  const forceUpdate = useCallback(() => setCount(count + 1), [count])\n\n  return forceUpdate\n}\n","import { useState, useEffect } from 'react'\n\nexport default function useHasMounted() {\n  const [hasMounted, setHasMounted] = useState(false)\n  useEffect(() => {\n    setHasMounted(true)\n  }, [])\n  return hasMounted\n}\n","import { useLayoutEffect } from 'react'\n\nexport default function useLockBodyScroll(): void {\n  // useLaoutEffect callback return type is \"() => void\" type\n  useLayoutEffect((): (() => void) => {\n    // Get original body overflow\n    const originalStyle: string = window.getComputedStyle(\n      document.body,\n    ).overflow\n    // Prevent scrolling on mount\n    document.body.style.overflow = 'hidden'\n    // Re-enable scrolling when component unmounts\n    return () => {\n      document.body.style.overflow = originalStyle\n    }\n  }, []) // Empty array ensures effect is only run on mount and unmount\n}\n","import { isSSR } from '@dwarvesf/react-utils'\nimport { useCallback, useEffect, useState } from 'react'\n\nexport default function useMedia<T>(\n  queries: string[],\n  values: T[],\n  defaultValue: T,\n) {\n  // Array containing a media query list for each query\n  const mediaQueryLists = isSSR()\n    ? []\n    : queries.map((q) => window.matchMedia(q))\n\n  const getValue = useCallback(() => {\n    const index = mediaQueryLists.findIndex((mql) => mql.matches)\n    return values?.[index] || defaultValue\n    // only form the function once\n    // eslint-disable-next-line\n  }, [])\n\n  const [value, setValue] = useState<T>(getValue)\n\n  useEffect(\n    () => {\n      // Event listener callback\n      // Note: By defining getValue outside of useEffect we ensure that it has ...\n      // ... current values of hook args (as this hook callback is created once on mount).\n      const handler = () => setValue(getValue)\n      mediaQueryLists.forEach((mql) => mql.addEventListener('change', handler))\n      return () =>\n        mediaQueryLists.forEach((mql) =>\n          mql.removeEventListener('change', handler),\n        )\n    },\n    // ensures effect is only run on mount and unmount\n    // eslint-disable-next-line\n    [],\n  )\n  return value\n}\n","import { useCallback, useEffect, useMemo, useState } from 'react'\n\nexport type UsePaginationParams = {\n  pageSize: number\n  totalPage: number\n  page: number\n}\n\nexport type UsePaginationResult = {\n  totalPage: number\n  pageSize: number\n  currentPage: number\n  // go to next page, optionally taking a boolean param to decide whether to go the last page immediately\n  next: (toLast?: boolean) => void\n  // back to previous page, optionally taking a boolean param to decide whether to go back to page 1 immediately\n  back: (toFirst?: boolean) => void\n  // jump to a specific page\n  go: (page: number) => void\n  hasNextPage: boolean\n  hasPreviousPage: boolean\n}\n\n/**\n * React hook that provides method for manipulating pages\n *\n * @param pageSize Required\n * @param page Required\n * @param totalPage Required\n */\nexport default function usePagination(\n  params: UsePaginationParams,\n): UsePaginationResult {\n  const { pageSize, totalPage, page: _page } = params\n\n  const [page, setPage] = useState(_page)\n\n  useEffect(() => {\n    setPage(params.page)\n  }, [params.page])\n\n  const hasNextPage = useMemo(() => page + 1 <= totalPage, [page, totalPage])\n  const hasPreviousPage = useMemo(() => page - 1 >= 1, [page])\n\n  const next = useCallback(\n    (toLast: boolean = false) => {\n      if (hasNextPage) {\n        if (toLast) {\n          setPage(totalPage)\n        } else {\n          setPage((p) => p + 1)\n        }\n      }\n    },\n    [hasNextPage, totalPage],\n  )\n\n  const back = useCallback(\n    (toFirst: boolean = false) => {\n      if (hasPreviousPage) {\n        if (toFirst) {\n          setPage(1)\n        } else {\n          setPage((p) => p - 1)\n        }\n      }\n    },\n    [hasPreviousPage],\n  )\n\n  const go = useCallback(\n    (page: number) => {\n      if (page >= 1 && page <= totalPage) {\n        setPage(page)\n      }\n    },\n    [totalPage],\n  )\n\n  return {\n    currentPage: page,\n    pageSize,\n    totalPage,\n    hasNextPage,\n    hasPreviousPage,\n    next,\n    back,\n    go,\n  }\n}\n","import { useEffect, useRef } from 'react'\n\nexport default function useWhyDidYouUpdate(\n  name: string,\n  props: Record<string, any>,\n) {\n  // Get a mutable ref object where we can store props ...\n  // ... for comparison next time this hook runs.\n  const previousProps = useRef<Record<string, any>>({})\n  useEffect(() => {\n    if (previousProps.current) {\n      // Get all keys from previous and current props\n      const allKeys = Object.keys({ ...previousProps.current, ...props })\n      // Use this object to keep track of changed props\n      const changesObj: Record<string, any> = {}\n      allKeys.forEach((key) => {\n        // If previous is different from current\n        if (previousProps.current[key] !== props[key]) {\n          // Add to changesObj\n          changesObj[key] = {\n            from: previousProps.current[key],\n            to: props[key],\n          }\n        }\n      })\n      // If changesObj not empty then output to console\n      if (Object.keys(changesObj).length) {\n        // eslint-disable-next-line no-console\n        console.log('[why-did-you-update]', name, changesObj)\n      }\n    }\n    // Finally update previousProps with current props for next hook call\n    previousProps.current = props\n  })\n}\n"],"names":["usePrevious","value","valueRef","useRef","useEffect","current","assignRef","ref","error","Error","events","callback","onDestroyOrDependencies","dependencies","deps","destroy","result","mounted","maybePromise","Promise","resolve","then","text","optionsOrTimeout","useState","hasCopied","setHasCopied","timeout","copyOptions","onCopy","useCallback","didCopy","copy","timeoutId","window","setTimeout","clearTimeout","init","delay","debouncedValue","setDebouncedValue","handler","props","onCloseProp","onClose","onOpenProp","onOpen","defaultIsOpen","isOpen","setIsOpen","prevIsOpen","onToggle","count","setCount","hasMounted","setHasMounted","useLayoutEffect","originalStyle","getComputedStyle","document","body","overflow","style","queries","values","defaultValue","mediaQueryLists","isSSR","map","q","matchMedia","getValue","index","findIndex","mql","matches","setValue","forEach","addEventListener","removeEventListener","refs","React","every","node","listener","event","contains","target","params","pageSize","totalPage","page","setPage","hasNextPage","useMemo","hasPreviousPage","next","toLast","p","back","toFirst","go","currentPage","name","previousProps","allKeys","Object","keys","changesObj","key","from","to","length","console","log"],"mappings":"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"}