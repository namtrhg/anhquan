'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var copy = _interopDefault(require('copy-to-clipboard'));
var reactUtils = require('@dwarvesf/react-utils');

/**
 * React hook that tracks previous value
 *
 * @param value the value to track
 */

function usePrevious(value) {
  var valueRef = React.useRef();
  React.useEffect(function () {
    valueRef.current = value;
  }, [value]);
  return valueRef.current;
}

function useDisclosure(props) {
  if (props === void 0) {
    props = {};
  }

  var _props = props,
      onCloseProp = _props.onClose,
      onOpenProp = _props.onOpen;

  var _useState = React.useState(props.defaultIsOpen || false),
      isOpen = _useState[0],
      setIsOpen = _useState[1];

  var prevIsOpen = usePrevious(isOpen);
  var onClose = React.useCallback(function () {
    setIsOpen(false);

    if (onCloseProp) {
      onCloseProp();
    }
  }, [onCloseProp]);
  var onOpen = React.useCallback(function () {
    setIsOpen(true);

    if (onOpenProp) {
      onOpenProp();
    }
  }, [onOpenProp]);
  var onToggle = React.useCallback(function () {
    var action = isOpen ? onClose : onOpen;
    action();
  }, [isOpen, onOpen, onClose]);
  return {
    isOpen: !!isOpen,
    prevIsOpen: !!prevIsOpen,
    onOpen: onOpen,
    onClose: onClose,
    onToggle: onToggle
  };
}

/**
 * React hook for force a component to re-render
 */

function useForceUpdate() {
  var _useState = React.useState(0),
      count = _useState[0],
      setCount = _useState[1];

  var forceUpdate = React.useCallback(function () {
    return setCount(count + 1);
  }, [count]);
  return forceUpdate;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var _excluded = ["timeout"];
/**
 * React hook to copy content to clipboard
 *
 * @param text the text or value to copy
 * @param {Number} [optionsOrTimeout=1500] optionsOrTimeout - delay (in ms) to switch back to initial state once copied.
 * @param {Object} optionsOrTimeout
 * @param {string} optionsOrTimeout.format - set the desired MIME type
 * @param {number} optionsOrTimeout.timeout - delay (in ms) to switch back to initial state once copied.
 */

function useClipboard(text, optionsOrTimeout) {
  if (optionsOrTimeout === void 0) {
    optionsOrTimeout = {};
  }

  var _useState = React.useState(false),
      hasCopied = _useState[0],
      setHasCopied = _useState[1];

  var _ref = typeof optionsOrTimeout === 'number' ? {
    timeout: optionsOrTimeout
  } : optionsOrTimeout,
      _ref$timeout = _ref.timeout,
      timeout = _ref$timeout === void 0 ? 1500 : _ref$timeout,
      copyOptions = _objectWithoutPropertiesLoose(_ref, _excluded);

  var onCopy = React.useCallback(function () {
    var didCopy = copy(text, copyOptions);
    setHasCopied(didCopy);
  }, [text, copyOptions]);
  React.useEffect(function () {
    var timeoutId = null;

    if (hasCopied) {
      timeoutId = window.setTimeout(function () {
        setHasCopied(false);
      }, timeout);
    }

    return function () {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [timeout, hasCopied]);
  return {
    value: text,
    onCopy: onCopy,
    hasCopied: hasCopied
  };
}

function useLockBodyScroll() {
  // useLaoutEffect callback return type is "() => void" type
  React.useLayoutEffect(function () {
    // Get original body overflow
    var originalStyle = window.getComputedStyle(document.body).overflow; // Prevent scrolling on mount

    document.body.style.overflow = 'hidden'; // Re-enable scrolling when component unmounts

    return function () {
      document.body.style.overflow = originalStyle;
    };
  }, []); // Empty array ensures effect is only run on mount and unmount
}

function useDebounce(value, delay) {
  // State and setters for debounced value
  var _useState = React.useState(value),
      debouncedValue = _useState[0],
      setDebouncedValue = _useState[1];

  React.useEffect(function () {
    // Update debounced value after delay
    var handler = setTimeout(function () {
      setDebouncedValue(value);
    }, delay); // Cancel the timeout if value changes (also on delay change or unmount)
    // This is how we prevent debounced value from updating if value is changed ...
    // .. within the delay period. Timeout gets cleared and restarted.

    return function () {
      clearTimeout(handler);
    };
  }, [value, delay]);
  return debouncedValue;
}

function useWhyDidYouUpdate(name, props) {
  // Get a mutable ref object where we can store props ...
  // ... for comparison next time this hook runs.
  var previousProps = React.useRef({});
  React.useEffect(function () {
    if (previousProps.current) {
      // Get all keys from previous and current props
      var allKeys = Object.keys(_extends({}, previousProps.current, props)); // Use this object to keep track of changed props

      var changesObj = {};
      allKeys.forEach(function (key) {
        // If previous is different from current
        if (previousProps.current[key] !== props[key]) {
          // Add to changesObj
          changesObj[key] = {
            from: previousProps.current[key],
            to: props[key]
          };
        }
      }); // If changesObj not empty then output to console

      if (Object.keys(changesObj).length) {
        // eslint-disable-next-line no-console
        console.log('[why-did-you-update]', name, changesObj);
      }
    } // Finally update previousProps with current props for next hook call


    previousProps.current = props;
  });
}

/**
 * Creates a constant value over the lifecycle of a component.
 *
 * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer
 * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`
 * you can ensure that initialisers don't execute twice or more.
 */

function useConst(init) {
  var ref = React.useRef(null);

  if (ref.current === null) {
    ref.current = typeof init === 'function' ? init() : init;
  }

  return ref.current;
}

/* eslint-disable react-hooks/exhaustive-deps */
function assignRef(ref, value) {
  if (ref == null) return;

  if (typeof ref === 'function') {
    ref(value);
    return;
  }

  try {
    // @ts-ignore
    ref.current = value;
  } catch (error) {
    throw new Error("Cannot assign value '" + value + "' to ref '" + ref + "'");
  }
}
/**
 * React hook that merges react refs into a single memoized function
 *
 * @example
 * import React from "react";
 * import { useMergeRefs } from `@chakra-ui/hooks`;
 *
 * const Component = React.forwardRef((props, ref) => {
 *   const internalRef = React.useRef();
 *   return <div {...props} ref={useMergeRefs(internalRef, ref)} />;
 * });
 */

function useMergeRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }

  return React.useMemo(function () {
    if (refs.every(function (ref) {
      return ref == null;
    })) {
      return null;
    }

    return function (node) {
      refs.forEach(function (ref) {
        if (ref) assignRef(ref, node);
      });
    };
  }, refs);
}

function useMedia(queries, values, defaultValue) {
  // Array containing a media query list for each query
  var mediaQueryLists = reactUtils.isSSR() ? [] : queries.map(function (q) {
    return window.matchMedia(q);
  });
  var getValue = React.useCallback(function () {
    var index = mediaQueryLists.findIndex(function (mql) {
      return mql.matches;
    });
    return (values == null ? void 0 : values[index]) || defaultValue; // only form the function once
    // eslint-disable-next-line
  }, []);

  var _useState = React.useState(getValue),
      value = _useState[0],
      setValue = _useState[1];

  React.useEffect(function () {
    // Event listener callback
    // Note: By defining getValue outside of useEffect we ensure that it has ...
    // ... current values of hook args (as this hook callback is created once on mount).
    var handler = function handler() {
      return setValue(getValue);
    };

    mediaQueryLists.forEach(function (mql) {
      return mql.addEventListener('change', handler);
    });
    return function () {
      return mediaQueryLists.forEach(function (mql) {
        return mql.removeEventListener('change', handler);
      });
    };
  }, // ensures effect is only run on mount and unmount
  // eslint-disable-next-line
  []);
  return value;
}

function useAsyncEffect(callback, onDestroyOrDependencies, dependencies) {
  if (onDestroyOrDependencies === void 0) {
    onDestroyOrDependencies = [];
  }

  if (dependencies === void 0) {
    dependencies = [];
  }

  var deps;
  var destroy;

  if (typeof onDestroyOrDependencies === 'function') {
    destroy = onDestroyOrDependencies;
    deps = dependencies;
  } else {
    deps = onDestroyOrDependencies || [];
  }

  React.useEffect(function () {
    var result;
    var mounted = true;
    var maybePromise = callback(function () {
      return mounted;
    });
    Promise.resolve(maybePromise).then(function (value) {
      result = value;
    });
    return function () {
      mounted = false;

      if (typeof destroy === 'function') {
        destroy(result);
      }
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);
}

var MOUSEDOWN = 'mousedown';
var TOUCHSTART = 'touchstart';
var events = [MOUSEDOWN, TOUCHSTART];
function useOnClickOutside(ref, handler) {
  React.useEffect(function () {
    if (!handler) {
      return;
    }

    var listener = function listener(event) {
      // Do nothing if clicking ref's element or descendent elements
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }

      handler(event);
    };

    events.forEach(function (event) {
      document.addEventListener(event, listener);
    });
    return function () {
      events.forEach(function (event) {
        document.removeEventListener(event, listener);
      });
    };
  }, // Add ref and handler to effect dependencies
  // It's worth noting that because passed in handler is a new ...
  // ... function on every render that will cause this effect ...
  // ... callback/cleanup to run every render. It's not a big deal ...
  // ... but to optimize you can wrap handler in useCallback before ...
  // ... passing it into this hook.
  [ref, handler]);
}

function useHasMounted() {
  var _useState = React.useState(false),
      hasMounted = _useState[0],
      setHasMounted = _useState[1];

  React.useEffect(function () {
    setHasMounted(true);
  }, []);
  return hasMounted;
}

/**
 * React hook that provides method for manipulating pages
 *
 * @param pageSize Required
 * @param page Required
 * @param totalPage Required
 */

function usePagination(params) {
  var pageSize = params.pageSize,
      totalPage = params.totalPage,
      _page = params.page;

  var _useState = React.useState(_page),
      page = _useState[0],
      setPage = _useState[1];

  React.useEffect(function () {
    setPage(params.page);
  }, [params.page]);
  var hasNextPage = React.useMemo(function () {
    return page + 1 <= totalPage;
  }, [page, totalPage]);
  var hasPreviousPage = React.useMemo(function () {
    return page - 1 >= 1;
  }, [page]);
  var next = React.useCallback(function (toLast) {
    if (toLast === void 0) {
      toLast = false;
    }

    if (hasNextPage) {
      if (toLast) {
        setPage(totalPage);
      } else {
        setPage(function (p) {
          return p + 1;
        });
      }
    }
  }, [hasNextPage, totalPage]);
  var back = React.useCallback(function (toFirst) {
    if (toFirst === void 0) {
      toFirst = false;
    }

    if (hasPreviousPage) {
      if (toFirst) {
        setPage(1);
      } else {
        setPage(function (p) {
          return p - 1;
        });
      }
    }
  }, [hasPreviousPage]);
  var go = React.useCallback(function (page) {
    if (page >= 1 && page <= totalPage) {
      setPage(page);
    }
  }, [totalPage]);
  return {
    currentPage: page,
    pageSize: pageSize,
    totalPage: totalPage,
    hasNextPage: hasNextPage,
    hasPreviousPage: hasPreviousPage,
    next: next,
    back: back,
    go: go
  };
}

exports.useAsyncEffect = useAsyncEffect;
exports.useClipboard = useClipboard;
exports.useConstant = useConst;
exports.useDebounce = useDebounce;
exports.useDisclosure = useDisclosure;
exports.useForceUpdate = useForceUpdate;
exports.useHasMounted = useHasMounted;
exports.useLockBodyScroll = useLockBodyScroll;
exports.useMedia = useMedia;
exports.useMergeRefs = useMergeRefs;
exports.useOnClickOutside = useOnClickOutside;
exports.usePagination = usePagination;
exports.usePrevious = usePrevious;
exports.useWhyDidYouUpdate = useWhyDidYouUpdate;
//# sourceMappingURL=react-hooks.cjs.development.js.map
